#!/usr/bin/env python3
"""Simple module and command line tool for finding anagrams
from a list of words.

A supplied list of words is collected into sublists,
with every member of the sublist being an anagram of the
others in that list.  Any single letter word will be ignored.

When running from command line, a list of words can be
supplied on stdin like so::

    $ cat /path/to/word/file | anagrams.py

or words can be manually entered by simply running
the script::

    $ anagrams.py

and ending the list with `CTRL-D` in the usual way.
The word list is expected to consist of one word per line
of input with empty lines being skipped.
"""

import sys
import argparse
from collections import defaultdict

__author__ = "Alan Collison"
__email__ = "alan@collison.net"
__status__ = "Prototype"


def hash_word(word):
    """Generate a hash key for a word.

    A (string) key is generated by sorting the letters in the word.
    Any two words that are anagrams of each other will have the
    same set of letters and numbers of each, so will generate
    the same hash key, which is what we want.

    Args:
        word: A string of a word to hash.

    Returns:
        A string hash key.
    """

    return ''.join(sorted(word))


def collect_anagrams(source, min_word_length=2):
    """Generates lists of anagrams from a source word list.

    The source can be any iterable that supplies a single
    word in each iteration.

    Args:
        source:  An iterable that generates a list of words.
        min_word_length:  the shortest words for which anagrams
            will be collected. Should be >= 2.  Defaults to 2.

    Returns:
        A mapping from a unique key for each anagram to the
        list of words that are anagrams of each other.  This
        is in the form of a `defaultdict` object with the keys
        generated by the `hash_word` function.
    """

    assert min_word_length > 1

    anagrams = defaultdict(set)  # `set` b/c words may be repeated in source

    for entry in source:
        word = entry.strip()  # we are expecting one word per line
        if len(word) < min_word_length:
            continue

        key = hash_word(word)
        anagrams[key].add(word)

    return anagrams

def filter_anagrams(anagrams, match_word_length=False):
    """Trim down the list to only relevant word lists.

    This removes any word without an anagram and
    removes anagram lists that are shorter than the
    length of the words in the list, if chosen.

    Args:
        anagrams:  A collected list of anagrams (a `defaultdict` object).
        match_word_length:  True if only lists are as long as
            individual words in the list.

    Returns:
        A generator with one anagram `set` returned at a time.
    """

    for key, alist in anagrams.items():
        if len(alist) < 2 or (match_word_length and (len(alist) < len(key))):
            continue
        yield alist


def _main():
    """Main command line execution.

    Placed here to make pylint happy.
    """

    def min_length_type(value):
        """Custom type for command line option.

        Requires that the minimum value supplied
        by command line arguments for `minlength`
        be at least 2 (Q: simply reset anything
        less than 2 instead?)
        """

        msg = 'Value must be an integer 2 or greater'
        # make sure it's an int
        try:
            value = int(value)
        except ValueError:
            raise argparse.ArgumentTypeError(msg)

        # make sure it makes sense
        if value < 2:
            raise argparse.ArgumentTypeError(msg)

        return value

    parser = argparse.ArgumentParser(description='Transform an arbitrary list '
                                     'of words into collections of anagrams.')
    parser.add_argument('-f', '--file', help='file to load the words from')
    parser.add_argument('-l', '--minlength', type=min_length_type, default=4,
                        help='minimum word length to consider '
                        '(2 or more letters)')
    parser.add_argument('-m', '--nomatch', action='store_false',
                        help='do Not require at least as many anagrams '
                        'as word length')
    args = parser.parse_args()

    handle = None
    try:
        # if supplied with a file name, use that, otherwise
        # look at stdin
        handle = open(args.file) if args.file else sys.stdin
    except (OSError, IOError) as ioe:
        sys.stderr.write('Failed to read word list: %s\n' % ioe.strerror)
        exit(1)

    anagrams = collect_anagrams(handle, min_word_length=args.minlength)
    for alist in filter_anagrams(anagrams, match_word_length=args.nomatch):
        print(", ".join(sorted(list(alist))).rstrip())

    # will be closed at end of execution anyway, but let's not be sloppy
    handle.close()


if __name__ == '__main__':

    _main()
